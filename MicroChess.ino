/**
 * ArduinoChess.ino
 * 
 * the MicroChess project: https://github.com/ripred/MicroChess
 * 
 * written March 2023 - Trent M. Wyatt
 * 
 * version 1.0.0
 *   First base
 * 
 * version 1.1.0
 * Modified board_t to save 16 bytes
 * 
 * version 1.2.0
 * Added evaluation
 * 
 * version 1.3.0
 * Added storage for pieces and moves, printf adjustable print debugging
 * 
 * version 1.4.0
 * Added board traversal, pawn movements
 * 
 * version 1.5.0
 * Added knight movements
 * 
 * version 1.6.0
 * Added move execution
 * 
 * version 1.7.0
 * Major bug fixes in piece tracking and move generation
 * 
 * version 1.8.0
 * Added Rook, Bishop, Queen, and King move generation
 * Added 'in check' attributes
 * Added 'has moved' attributes
 * 
 * version 1.9.0
 * 
 *  [+] fix and test the new Rook, Bishop, Queen, and King pieces
 *  [+] create new macro for printf that automatically declares the
 *      format string as a PROGMEM array behind the scenes without
 *      requiring a PROGMEM to be decared at each use of printf(...)!
 *  [+] replace all checks for Empty == getType(p) with isEmpty(p)
 *  [+] add the ability turn off all output in order to profile 
 *      the engine without waiting on serial i/o.
 *  [+] move the offsets into PROGMEM.
 *  [+] add pawn promotion to queen when reaching the last row.
 *  [+] move the move generation for each Piece type into it's own function.
 *  [+] create a separate file for each piece.
 *  [+] add precomputed tables for the material bonuses calculated by evaluate(...) at runtime.
 *  [+] add precomputed tables for the center bonuses calculated by evaluate(...) at runtime.
 *  [+] add the time spent and number of moves evaluated on the last move to the status area
 * 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * TODO: for version 1.10.0
 * 
 *  [+] change the api for the individual Piece generation functions so that
 *      the same "best move" move_t object is passed throughout and remove
 *      the best move objects from the main game_t!
 *
 *  [+] add ply level awareness and recursion.
 *  [+] get rid of move lists!
 *  [+] evaluate each move as it is generated by the pieces, remember the best one!
 *  [+] add castling.
 *  [+] update the show_move(...) function to properly display when a pawn executes 
 *      an en-passant capture. ?
 *  [+] add and implement a "deleted" flag for pieces in the game.pieces[] list so they are ignored
 *      during moves that take pieces instead of needing to move/copy the taken piece from the list
 *  [ ] add minimax algorithm.
 *  [ ] add alpha-beta pruning.
 *  [ ] add reading and writing of FEN notation.
 *  [ ] 
 * 
 * BUGBUGS: to fix!
 * 
 *  [ ] 
 * 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * 
 */
#include <Arduino.h>
#include "MicroChess.h"

////////////////////////////////////////////////////////////////////////////////////////
// the game board
board_t board;

////////////////////////////////////////////////////////////////////////////////////////
// the currently running game
game_t game;

////////////////////////////////////////////////////////////////////////////////////////
// Function to check if a move is better than the current best move
// 
// returns True if move is better, False otherwise
Bool is_better_move(
    move_t const &move, 
    move_t const &best, 
    Bool const use_random, 
    Color const side) {

    if (-1 == move.from) {
        return True;
    }

    if (side == White) {
        if (move.value > best.value) {
            return True;
        }
        else if (move.value == best.value) {
            return use_random && random(2);
        }
    }
    else {
        if (move.value < best.value) {
            return True;
        }
        else if (move.value == best.value) {
            return use_random && random(2);
        }
    }

    return False;

}   // is_better_move(...)


////////////////////////////////////////////////////////////////////////////////////////
// Consider a move against the best white move or the best black move
// depending on the color of the piece and set this as the best move
// if it has a higher value (or an equal value when we're using random)
// 
// returns True if the move is the new best move, False otherwise
Bool consider_move(move_t &move, move_t &best) 
{
    Piece const p = board.get(move.from);
    Color const side = getSide(p);

    // Piece const op = board.get(move.to);
    // Piece const otype = getType(op);
    // Color const oside = getSide(op);

    // don't allow us to take our own pieces

    // if (Empty != otype && side == oside) {
    //     printf(Debug1, "Error: attempt to take own piece at line %d: ", __LINE__);
    //     show_move(move);
    //     printf(Debug1, "\n");
    //     // while ((true)) {}
    //     return False;
    // }

    // Make the move_t object for the move (recursively) and it's evaluation
    move.value = make_move(move, True);

    // penalize the move if it would cause us to lose by 3-move repetition
    if (would_repeat(move)) {
        move.value += ((White == side) ? -1 : +1) * 5000;
    }

    // trace the call
    // print_t const dbg = Debug2;
    // printf(dbg, "call to consider_move(%d, %2d, %2d, %5ld) = ", 
    //     side, move.from, move.to, move.value);

    // if (game.options.print_level >= dbg) {
    //     show_move(move);
    // }

    // check if the move is better than the current best move
    if (is_better_move(move, best, game.options.random, side)) {
        best = move;
        // printf(Debug2, "*\n");
        return True;
    }

    // printf(dbg, "\n");
    return False;

}   // consider_move(move_t &move, move_t &best)


////////////////////////////////////////////////////////////////////////////////////////
// Find the piece index for a given board index.
// 
// returns the index into the game.pieces[] array for the specified piece
inline index_t find_piece(index_t const index) 
{
    for (index_t piece_index = 0; piece_index < game.piece_count; piece_index++) {
        point_t const &loc = game.pieces[piece_index];
        index_t const board_index = loc.x + loc.y * 8;

        if (board_index == index) {
            return piece_index;
        }
    }

    return -1;

}   // find_piece(int const index)


////////////////////////////////////////////////////////////////////////////////////////
// Move a piece on the board, taking a piece if necessary. Evaluate the value of the 
// board after the move. Optionally restore the board back to it's original state after
// evaluating the value of the move.
// 
// This is a big and complicated function.
// It performs 5 Basics steps:
// 
//  1) Identify the piece being moved
//  2) Identify any piece being captured and remove it if so
//  3) Place the piece being moved at the destination
//  4) Evaluate the board score after making the move
//  5) If we are just considering the move then put everything back
// 
// returns the value of the board after the move was made
long make_move(move_t const &move, Bool const restore) 
{
    // Step 1: Identify the piece being moved
    // Modified in game.* :
    // 
    // step 1:
    // game.stats.inc_moves_count();
    // game.stats.max_moves = move_count;
    // game.black_king_in_check = True;
    // game.white_king_in_check = True;


    // Get the attributes for the piece being moved
    index_t const col = move.from % 8;
    index_t const row = move.from / 8;

    // Check for a deleted piece and skip it if so
    if (-1 == col || -1 == row) {
        if (White == game.turn) { return MIN_VALUE; } else { return MAX_VALUE; }
    }

    index_t const from = move.from;
    Piece   const piece = board.get(from);
    Piece   const type = getType(piece);
    Color   const side = getSide(piece);

    Bool const whites_turn = White == side;
    long const worst_value = whites_turn ? MIN_VALUE : MAX_VALUE;

    // Get the attributes for the destination location
    index_t const to_col = move.to % 8;
    index_t const to_row = move.to / 8;
    index_t const to = move.to;

    // Get the attributes for any possible piece being taken at the destination location
    Piece         op = board.get(to);
    Piece         otype = getType(op);
    Color         oside = getSide(op);

    // Ensure that we aren't trying to take our own piece
    // BUGBUG: Remove after testing
    if (Empty != otype && side == oside) {
        printf(Debug1, "attempt to take our own piece at line %d\n", __LINE__);
        while ((true)) {}
        // return worst_value;
    }

    // Save the current last 5 moves in the game history
    move_t history[5];
    index_t hist_count = game.hist_count;    

    if (restore) {
        memcpy(history, game.history, sizeof(history));

        // Track the number of moves considered so far
        game.stats.inc_moves_count();

        // Track the max number of moves generated during a turn
        uint32_t const move_count = game.stats.move_count_so_far();

        if (side == game.turn) {
            if (move_count > game.stats.max_moves) {
                game.stats.max_moves = move_count;
            }
        }
    }

    Bool const white_king_in_check = game.white_king_in_check;
    Bool const black_king_in_check = game.black_king_in_check;

    // Don't allow the kings to be taken
    if (King == otype) {
        if (whites_turn && Black == oside) {
            game.black_king_in_check = True;
            return worst_value;
        }

        if (!whites_turn && White == oside) {
            game.white_king_in_check = True;
            return worst_value;
        }
    }

    // Find the index of the piece being moved in the array of pieces in the game:
    index_t const piece_index = find_piece(from);


    // Step 2: Identify any piece being captured and remove it if so
    // Modified in game.* :
    // 
    // step 1:
    // game.stats.inc_moves_count();
    // game.stats.max_moves = move_count;
    // game.black_king_in_check = True;
    // game.white_king_in_check = True;
    // 
    // step 2:
    // game.last_was_en_passant = True;
    // game.pieces[taken_index] = { -1, -1 };
    // game.taken_count1++;
    // game.taken_count2++;


    // The game.pieces[] index being captured (if any, -1 if none)
    index_t taken_index = -1;

    // The board index being captured (if any, -1 if none)
    index_t captured = -1;

    // save the current number of taken pieces
    index_t const taken_count1 = game.taken_count1;
    index_t const taken_count2 = game.taken_count2;

    // save the current last move and en-passant flag
    Bool const last_was_en_passant = game.last_was_en_passant;
    move_t const last_move = game.last_move;

    Piece captured_piece = Empty;

    if (type == Pawn && isEmpty(otype) && col != to_col) {
        // en-passant capture
        game.last_was_en_passant = True;

        captured = to_col + row * 8;
    }
    else {
        // See if the destination is not empty and not a piece on our side.
        // i.e. an opponent's piece.
        if (Empty != otype && side != oside) {
            captured = to;
        }
    }

    // If a piece was taken, make the change on the board and to the game.pieces[] list
    if (-1 != captured) {
        captured_piece = board.get(captured);

        // change the spot on the board for the taken piece to Empty
        board.set(captured, Empty);

        // remember the piece index of the piece being taken
        taken_index = find_piece(captured);

        // Soft-delete the piece taken in the piece list!
        game.pieces[taken_index] = { -1, -1 };

        // add the piece to the list of taken pieces
        if (whites_turn) {
            game.taken_count1++;

            // BUGBUG: remove after testing
            if (game.taken_count1 > 16) {
                printf(Debug1, "Error: Attempt to take more than 16 pieces at line %d\n", __LINE__);
                while ((true)) {}
            }
            game.taken1[game.taken_count1] = captured_piece;
        }
        else {
            game.taken_count2++;

            // BUGBUG: remove after testing
            if (game.taken_count2 > 16) {
                printf(Debug1, "Error: Attempt to take more than 16 pieces at line %d\n", __LINE__);
                while ((true)) {}
            }
            game.taken2[game.taken_count2] = captured_piece;
        }
    }

    // Step 3: Place the piece being moved at the destination
    // Modified in game.* :
    // 
    // step 1:
    // game.stats.inc_moves_count();
    // game.stats.max_moves = move_count;
    // game.black_king_in_check = True;
    // game.white_king_in_check = True;
    // 
    // step 2:
    // game.last_was_en_passant = True;
    // game.pieces[taken_index] = { -1, -1 };
    // game.taken_count1++;
    // game.taken_count2++;
    // 
    // step 3:
    // game.pieces[piece_index] = { to_col, to_row };


    Piece place_piece = setMoved(piece, True);

    // Promote a pawn to a queen if it reached the back row
    if (Pawn == type && (to_row == ((whites_turn) ? index_t(0) : index_t(7)))) {
        place_piece = setType(place_piece, Queen);
    }

    // Move the piece to the destination on the board
    board.set(from, Empty);
    board.set(to, place_piece);

    // move the piece in the piece list
    game.pieces[piece_index] = { to_col, to_row };


    // Step 4: Evaluate the board score after making the move
    // Modified in game.* :
    // 
    // step 1:
    // game.stats.inc_moves_count();
    // game.stats.max_moves = move_count;
    // game.black_king_in_check = True;
    // game.white_king_in_check = True;
    // 
    // step 2:
    // game.last_was_en_passant = True;
    // game.pieces[taken_index] = { -1, -1 };
    // game.taken_count1++;
    // game.taken_count2++;
    // 
    // step 3:
    // game.pieces[piece_index] = { to_col, to_row };
    // 
    // step 4:
    // game.last_move = move;
    // if (whites_turn) { game.white_king = to; }
    // else { game.black_king = to; }
    // game.ply++;
    // ++game.turn %= 2;


    long value = evaluate();

    // set our move as the last move
    game.last_move = move;

    // keep track of the kings
    index_t const white_king = game.white_king;
    index_t const black_king = game.black_king;
    if (King == type) {
        if (whites_turn) { game.white_king = to; }
        else { game.black_king = to; }
    }

    ////////////////////////////////////////////////////////////////////////////////////////
    // The move has been made and we have the value for the updated board.
    // Recursively look-ahead and accumulatively update the value here.
    // TODO: Once this is working in brute-force mode,
    //       Implement minimax and alpha-beta pruning!
    ////////////////////////////////////////////////////////////////////////////////////////

    if (game.ply < game.options.maxply) {
        game.ply++;
        ++game.turn %= 2;

        Bool const white_king_in_check = game.white_king_in_check;
        Bool const black_king_in_check = game.black_king_in_check;

        index_t const taken_count21 = game.taken_count1;
        index_t const taken_count22 = game.taken_count2;

        reset_move_flags();

        if (whites_turn) {
            move_t best_black = { -1, -1, MAX_VALUE };
            choose_best_move(Black, best_black, consider_move);
            value = best_black.value;
        }
        else {
            move_t best_white = { -1, -1, MIN_VALUE };
            choose_best_move(White, best_white, consider_move);
            value = best_white.value;
        }

        game.taken_count1 = taken_count21;
        game.taken_count2 = taken_count22;

        game.white_king_in_check = white_king_in_check;
        game.black_king_in_check = black_king_in_check;

        ++game.turn %= 2;
        game.ply--;
    }

    // Step 5: If we are just considering the move then put everything back
    // that was modified in game.*


    if (restore) {
        if (-1 == captured) {
            board.set(to, op);
        } else {
            index_t const captured_col = captured % 8;
            index_t const captured_row = captured / 8;

            // restore the captured board changes
            board.set(captured, captured_piece);

            // restore the captured piece list changes
            game.pieces[taken_index] = { captured_col, captured_row };

            // restore the taken pieces list changes
            game.taken_count1 = taken_count1;
            game.taken_count2 = taken_count2;
        }

        // restore the changes made to the moves history
        memcpy(game.history, history, sizeof(history));
        game.hist_count = hist_count;

        // restore the moved piece board changes
        board.set(from, piece);

        // restore the moved piece pieces list changes
        game.pieces[piece_index] = { col, row };

        // restore the location of the kings
        game.white_king = white_king;
        game.black_king = black_king;

        // restore the last move made
        game.last_move = last_move;

        game.white_king_in_check = white_king_in_check;
        game.black_king_in_check = black_king_in_check;

        // restore the en passant 
        game.last_was_en_passant = last_was_en_passant;
    }

    return value;

}   // make_move(move_t const &move, Bool const restore)


////////////////////////////////////////////////////////////////////////////////////////
// Evaluate the identity (score) of the board state.
// Positive scores indicate an advantage for white and
// Negative scores indicate an advantage for black.
// Uses pre-computed material bonus tables for speed.
// 
// returns the score/value of the current board
long evaluate() 
{
    // flags choices for which attributes are included in the board score
    static uint8_t const material = 0x01u;
    static uint8_t const   center = 0x02u;
    // static uint8_t const mobility = 0x04u;

    // Adjust as desired
    // Note: Do not include mobility unless you are prepared to evaluate all moves
    // for both sides for future plies. On the first pass when neither side has any moves
    // this gives favor to White when the Black response moves have not been generated yet
    static uint8_t const   filter = material | center;

    // calculate the value of the board
    long materialTotal = 0L;
    long mobilityTotal = 0L;
    long centerTotal = 0L;
    long score = 0L;

    // iterate over the pieces on the board if necessary
    if (filter & (material | center)) {
        for (index_t piece_index = 0; piece_index < game.piece_count; piece_index++) {
            index_t const col = game.pieces[piece_index].x;
            index_t const row = game.pieces[piece_index].y;
            if (-1 == col || -1 == row) continue;

            Piece   const p = board.get(col + row * 8);
            Piece   const ptype = getType(p);
            Color   const pside = getSide(p);

            if (Empty == ptype) continue;

            if (filter & material) {
                materialTotal += pgm_read_dword(&material_bonus[ptype][pside]);
            }

            // Let's not encourage the King to wander to
            // the center of the board mmkay?
            if (King == ptype) {
                continue;
            }

            if (filter & center) {
                centerTotal +=
                    pgm_read_dword(&center_bonus[col][ptype][pside]) +
                    pgm_read_dword(&center_bonus[row][ptype][pside]);
            }
        }
    }

    // The score or 'identity property' of the board can include extra points for
    // how many total moves (mobility) the remaining pieces can make
    // if (filter & mobility) {
    //     long sideFactor = (Black == side) ? -1 : 1;
    //     mobilityTotal += static_cast<long>(game.move_count1 * mobilityBonus * sideFactor);
    //     mobilityTotal -= static_cast<long>(game.move_count2 * mobilityBonus * sideFactor);
    // }

    score = materialTotal + centerTotal + mobilityTotal;

    // printf(Debug4, 
    //     "evaluation: %ld = centerTotal: %ld  materialTotal: %ld  mobilityTotal: %ld\n", 
    //     score, centerTotal, materialTotal, mobilityTotal);

    return score;

}   // evaluate()


////////////////////////////////////////////////////////////////////////////////////////
// reset the various move tracking flags
void reset_move_flags() 
{
    for (index_t ndx = 0; ndx < game.piece_count; ndx++) {
        index_t const col = game.pieces[ndx].x;
        index_t const row = game.pieces[ndx].y;
        index_t const from = col + row * 8;
        Piece   const p = board.get(from);

        board.set(from, setCheck(p, False));
    }

    // reset the king-in-check flags
    game.white_king_in_check = False;
    game.black_king_in_check = False;

    game.last_was_en_passant = False;

}   // reset_move_flags()


////////////////////////////////////////////////////////////////////////////////////////
// Sanitize a list of moves to remove any that leave the king in check.
// 
// returns the nubmer of moves left in the updated list
index_t sanitize_moves(move_t *moves, index_t count) {
    if (0 == count) return 0;

    // // If we are White then we want to get Black's responses to see if any of them put our King in check
    // // If we are Black then we want to get White's responses to see if any of them put our King in check

    Bool const whites_turn = White == getSide(board.get(moves[0].from));
    // index_t maxply = game.options.maxply;
    // game.options.maxply = 0;

    // // eliminate moves that leave our king in check
    // for (index_t i = 0; i < count; i++) {
    //     move_t dummy = { -1, -1, 0 };
    //     reset_move_flags();
    //     make_move(moves[i], True);

    //     if (whites_turn) {
    //         // iterate through all of the black responses to see if any of them place our king in check
    //         choose_best_move(Black, dummy, consider_move, nullptr);
    //         if (game.white_king_in_check) {
    //             moves[i].from = -1;
    //             moves[i].to = -1;
    //         }
    //     }
    //     else {
    //         // iterate through all of the white responses to see if any of them place our king in check
    //         choose_best_move(White, dummy, consider_move, nullptr);
    //         if (game.black_king_in_check) {
    //             moves[i].from = -1;
    //             moves[i].to = -1;
    //         }
    //     }
    // }

    // game.options.maxply = maxply;

    // move_t new_moves[16];
    // index_t new_move_count = 0;

    // for (index_t i = 0; i < count; i++) {
    //     if (-1 != moves[i].from && -1 != moves[i].to) {
    //         new_moves[new_move_count++] = moves[i];
    //     }
    // }

    // for (index_t i = 0; i < new_move_count; i++) {
    //     moves[i] = new_moves[i];
    // }

    // count = new_move_count;

    if (count > 1) {
        // lambda comparator to sort the moves in ascending order
        auto const ac = [](const void *a, const void *b) -> int {
            move_t const move_a = *((move_t*) a);
            move_t const move_b = *((move_t*) b);
            return (move_a.value == move_b.value) ?  
                0 : (move_a.value  < move_b.value) ? +1 : -1;
        };

        // lambda comparator to sort the moves in decending order
        auto const dc = [](const void *a, const void *b) -> int {
            move_t const move_a = *((move_t*) a);
            move_t const move_b = *((move_t*) b);
            return (move_a.value == move_b.value) ?  
                0 : (move_a.value  < move_b.value) ? -1 : +1;
        };

        auto comparator = whites_turn ? ac : dc;
        qsort(moves, count, sizeof(move_t), comparator);
    }

    return count;

}   // sanitize_moves(move_t *moves, index_t count)


////////////////////////////////////////////////////////////////////////////////////////
// Evaluate all of the available moves for the specified side.
// The best move is stored in best.
// The callback is called for each move.
// 
// returns the number of pieces that can move,
// which is also the number of moves stored in the *moves array
// if the pointer is not nullptr.
index_t choose_best_move(Color const who, move_t &best, generator_t callback, move_t * const moves /* = nullptr */)
{
    static Bool constexpr   enable_pawns = True;
    static Bool constexpr enable_knights = True;
    static Bool constexpr enable_bishops = True;
    static Bool constexpr   enable_rooks = True;
    static Bool constexpr  enable_queens = True;
    static Bool constexpr   enable_kings = True;

    Bool const whites_turn = White == who ? True : False;
    long const worst_value = whites_turn ? MIN_VALUE : MAX_VALUE;

    // the number of pieces we have a move for
    index_t count = 0;

    // walk through the pieces list and generate all moves for each piece
    for (index_t ndx = 0; ndx < game.piece_count; ndx++) {
        index_t const col = game.pieces[ndx].x;
        index_t const row = game.pieces[ndx].y;
        if (-1 == col || -1 == row) continue;

        index_t const from = col + row * 8;
        Piece   const p = board.get(from);
        Piece   const type = getType(p);
        Color   const side = getSide(p);

        if (Empty == type || side != who) { continue; }

        // construct a move_t object with the starting location
        move_t move = { from, 0, worst_value };
        move_t best_piece_move = { -1, -1, worst_value };
        piece_gen_t gen(move, best_piece_move, callback);

        switch (type) {
            case   Pawn: if ((enable_pawns))   {   add_pawn_moves(gen); }  break;
            case Knight: if ((enable_knights)) { add_knight_moves(gen); }  break;
            case Bishop: if ((enable_bishops)) { add_bishop_moves(gen); }  break;
            case   Rook: if ((enable_rooks))   {   add_rook_moves(gen); }  break;
            case  Queen: if ((enable_queens))  {  add_queen_moves(gen); }  break;
            case   King: if ((enable_kings))   {   add_king_moves(gen); }  break;

            default:
                printf(Debug1, "error: invalid type = %d\n", type);
                game.options.print_level = Debug1;
                show();
                game.stats.stop_game_stats();
                show_stats();
                while ((1)) {}
                break;
        }

        // All of the moves for this one piece have been generated and evaluated and the best move
        // is stored in 'best_piece_move'. If the best move for the piece is legal then compare
        // it against the best move so far and update it if it is better.
        if (-1 != best_piece_move.from && -1 != best_piece_move.to) {
            if ((-1 == best.from) || (best_piece_move.value > best.value)) {
                best = best_piece_move;
            }
            else if ((best_piece_move.value == best.value) && game.options.random && random(2)) {
                best = best_piece_move;
            }

            if (nullptr != moves) {
                moves[count] = best_piece_move;
            }
            count++;
        }

        // sanity check - remove when no longer a problem
        if (count >= 16) {
            printf(Debug1, "Error: too many moves for array at line %d\n", __LINE__);
            while ((true)) {}
        }

    } // for each piece for this side..

    // If we have kept all of the best moves for each piece then
    // go through the list and remove any illegal moves
    if (nullptr != moves) {
        count = sanitize_moves(moves, count);
        best = { -1, -1, worst_value };
        index_t i = 0;
        if (count > 1) {
            for (i = 1; i < count; i++) {
                if (moves[i].value != moves[i - 1].value) {
                    break;
                }
            }
        }
        best = moves[random(i)];
    }

    // return the number of pieces that have a best move
    return count;

}   // choose_best_move()


////////////////////////////////////////////////////////////////////////////////////////
// see if a move would violate the 3-move repetition rule
// 
// returns True if the move would violate the rule and end the game, otherwise False
Bool would_repeat(move_t move) 
{
    index_t const total = MAX_REPS * 2 - 1;

    if (game.hist_count < total) {
        return False;
    }

    Bool result = True;

    move_t &m= move;

    for (index_t i = 1; i < total; i += 2) {
        if (game.history[i].to == m.from && game.history[i].from == m.to) {
            m = game.history[i];
        }
        else {
            result = False;
            break;
        }
    }

    return result;

}   // would_repeat(move_t const move)


////////////////////////////////////////////////////////////////////////////////////////
// Add a move to the partial history list and check for 3-move repetition
// 
// returns True if the move violates the rule and end the game, otherwise False
Bool add_to_history(move_t const &move)
{
    Bool result = would_repeat(move);

    memmove(&game.history[1], &game.history[0], sizeof(move_t) * 4);
    game.history[0] = move;
    if (game.hist_count < 5) {
        game.hist_count++;
    }

    return result;

}   // add_to_history()


////////////////////////////////////////////////////////////////////////////////////////
// Make the next move in the game until we reach a stalemate or checkmate
// 
void play_game() 
{
    show();

    Bool const whites_turn = (White == game.turn) ? True : False;

    game.stats.start_move_stats();

    // determine the next best moves
    printf(Debug3, "(\n"
                   "evaluating all available moves..\n\n");

    move_t moves[16];

    reset_move_flags();

    move_t best_white = { -1, -1, MIN_VALUE };
    Bool white_king_in_check = game.white_king_in_check;
    Bool no_white_moves = (-1 == best_white.from);

    move_t best_black = { -1, -1, MAX_VALUE };
    Bool black_king_in_check = game.black_king_in_check;
    Bool no_black_moves = (-1 == best_black.from);

    if (whites_turn) {
        // get the best move and flags for white
        choose_best_move(White, best_white, consider_move, moves);
        white_king_in_check = game.white_king_in_check;
        no_white_moves = (-1 == best_white.from);
    }
    else {
        // get the best move and flags for black
        choose_best_move(Black, best_black, consider_move, moves);
        black_king_in_check = game.black_king_in_check;
        no_black_moves = (-1 == best_black.from);
    }

    // gather the move statistics
    game.stats.stop_move_stats();
    game.last_move_time = game.stats.move_stats.duration();
    game.last_moves_evaluated = game.stats.move_stats.counter();


    // see if we've hit the move limit
    if (game.move_num >= game.options.move_limit) {
        game.state = FIFTY_MOVES;
        return;
    }

    // see if we have a stalemate
    if (no_white_moves && no_black_moves) {
        game.state = STALEMATE;
        return;
    }
    
    // see if the game has been won
    if (whites_turn && no_black_moves && black_king_in_check) {
        game.state = WHITE_CHECKMATE;
        return;
    }

    if (!whites_turn && no_white_moves && white_king_in_check) {
        game.state = BLACK_CHECKMATE;
        return;
    }

    move_t const &move = whites_turn ? best_white : best_black;

    // Display the move that we chose * Before Modifying the Board *
    printf(Debug1, "\nMove #%d: ", game.move_num + 1);
    show_move(move);

    // Make the move:
    make_move(move, False);

    if (game.last_was_en_passant) {
        printf(Debug1, " en passant capture")
    }

    printf(Debug1, "\n");

    // Announce if either king is in check
    if (white_king_in_check) {
        printf(Debug1, "White King is in check!\n");
        if (White == game.turn) {
            printf(Debug1, "illegal move\n");
        }
    }

    if (black_king_in_check) {
        printf(Debug1, "Black King is in check!\n");
        if (Black == game.turn) {
            printf(Debug1, "illegal move\n");
        }
    }

    printf(Debug1, "\n");

    // check for 3-move repetition
    if (add_to_history(move)) {
        game.state = whites_turn ? WHITE_3_MOVE_REP : BLACK_3_MOVE_REP;
    }

    // toggle whose turn it is
    ++game.turn %= 2;

    // increase the game moves counter
    game.move_num++;

}   // play_game()


////////////////////////////////////////////////////////////////////////////////////////
// Set all of the options for the game
// 
void set_game_options() 
{
    // set game.options.profiling to True (1) to disable output and profile the engine
    game.options.profiling = False;
    // game.options.profiling = True;

    // set the maximum ply level (the number of turns we look ahead) for the game
    game.options.maxply = 2;

    // set the limit on the total number of moves allowed in the game
    // Officially the limit is 50 moves
    game.options.move_limit = 200;

    // set game.options.random to True (1) to use randomness in the game decisions
    // game.options.random = False;
    game.options.random = True;

    // game seed hash for PRN generator - default to 4 hex prime numbers
    game.options.seed = 0x232F89A3;
    uint16_t upper = game.options.seed >> 16;
    uint16_t lower = word(game.options.seed);

    // Enable random seed when program is debugged.
    // Disable random seed to reproduce issues or to profile.
    if (game.options.profiling) {
        printf(Debug1, "profiling. ");

        // game.options.random = False;
        game.options.print_level = None;
    } 

    // Salt the psuedo-random number generator seed if enabled:
    if (game.options.random) {
        // Add salt to the psuedo random number generator seed
        // from the physical environment
        uint8_t const pins[10] = { 2, 3, 4, 5, 7, 8, 9, 10, 11, 12 };
        uint8_t const total_passes = random(23, 87);
        uint32_t some_bits = 1234567890;

        randomSeed(random());

        for (uint8_t pass = 0; pass < total_passes; pass++) {
            for (uint8_t pin = 0; pin < 10; pin++) {
                pinMode(pins[pin], INPUT);
                some_bits ^= digitalRead(pins[pin]) << (analogRead(A2) % 3);                
            }
        }
        uint8_t bits = (game.options.seed >> 11) & 0xFF;
        game.options.seed += 
            bits +
            (uint32_t(analogRead(A0)) << 24) +
            (uint32_t(analogRead(A1)) << 16) +
            (uint32_t(analogRead(A2)) << 17) +
            (uint32_t(analogRead(A3)) << 11) +
            uint32_t(analogRead(A4)) +
            uint32_t(micros());

        game.options.seed += some_bits;        

        upper = game.options.seed >> 16;
        lower = word(game.options.seed);
    }

    printf(Always, "game hash: 0x%04X%04X\n", upper, lower);
    printf(Always, "game ply limit: %d\n\n", game.options.maxply);

    randomSeed(game.options.seed);

}   // set_game_options()


////////////////////////////////////////////////////////////////////////////////////////
// Continually call play_game() until we reach the end of the game.
// Display the statistics for the game and start another game.
// 
// int main(int /* argc */, char */* argv*/[] ) 
void setup() 
{
    Serial.begin(115200); while (!Serial); Serial.write('\n');

    uint32_t state_totals[6] = { 0, 0, 0, 0, 0, 0 };
    uint32_t white_wins = 0;
    uint32_t black_wins = 0;

    Bool constexpr continuous = True;

    do {
        Serial.println("starting..");

        set_game_options();

        // initialize the board and the game:
        board.init();
        game.init();

        game.stats.start_game_stats();

        do {
            play_game();

        } while (PLAYING == game.state);

        game.stats.stop_game_stats();

        Serial.println("finished.\n");

        game.options.print_level = Debug1;

        switch (game.state) {
            case STALEMATE:
                printf(Debug1, "Stalemate\n\n");
                break;
            
            case WHITE_CHECKMATE:
                printf(Debug1, "Checkmate! White wins!\n\n");
                break;

            case BLACK_CHECKMATE:
                printf(Debug1, "Checkmate! Black wins!\n\n");
                break;

            case WHITE_3_MOVE_REP:
                printf(Debug1, "3-move repetition! Black wins!\n\n");
                break;

            case BLACK_3_MOVE_REP:
                printf(Debug1, "3-move repetition! White wins!\n\n");
                break;

            case FIFTY_MOVES:
                printf(Debug1, "%d-move limit reached!\n\n", game.options.move_limit);
                break;

            default:
            case PLAYING:
                break;
        }

        // show the final board    
        show();

        // print out the game move counts and time statistics
        show_stats();

        state_totals[game.state - 1]++;

        char str_wcheck[16] = "";
        char str_bcheck[16] = "";
        char str_wrep[16] = "";
        char str_brep[16] = "";
        char str_fifty[16] = "";

        strcpy(str_wcheck, addCommas(state_totals[WHITE_CHECKMATE - 1]));
        strcpy(str_bcheck, addCommas(state_totals[BLACK_CHECKMATE - 1]));
        strcpy(str_wrep, addCommas(state_totals[WHITE_3_MOVE_REP - 1]));
        strcpy(str_brep, addCommas(state_totals[BLACK_3_MOVE_REP - 1]));
        strcpy(str_fifty, addCommas(state_totals[FIFTY_MOVES - 1]));

        printf(Debug1, "   White Checkmate   Black Checkmate  White 3-Move Rep  Black 3-Move Rep        Move Limit\n");
        printf(Debug1, "%18s%18s%18s%18s%18s\n",
            str_wcheck,
            str_bcheck,
            str_wrep,
            str_brep,
            str_fifty);

        switch (game.state) {
            default:
            case PLAYING:
            case FIFTY_MOVES:
                break;

            case WHITE_CHECKMATE:
            case BLACK_3_MOVE_REP:
                white_wins++;
                break;

            case BLACK_CHECKMATE:
            case WHITE_3_MOVE_REP:
                black_wins++;
                break;
        }

        printf(Debug1, "   White wins: %3ld   Black wins: %3ld\n\n", white_wins, black_wins)
    
    } while (continuous);

}   // setup()

void loop() {}

////////////////////////////////////////////////////////////////////////////////////////
// display the game board
// 
void show()
{
    static char const icons[] = "pnbrqkPNBRQK";

    static const bool dev = true;

    long value = 0;

    index_t const offset = 0;

    for (unsigned char y = 0; y < 8; ++y) {
        printf(Debug1, "%c ", dev ? ('0' + y) : ('8' - y));
        for (unsigned char x = 0; x < 8; ++x) {
            Piece const piece = board.get(y * 8 + x);
            printf(Debug1, " %c ", 
                isEmpty(piece) ? ((y ^ x) & 1 ? '.' : '*') :
                icons[((getSide(piece) * 6) + getType(piece) - 1)]);
        }

        // display the extra status info on certain lines:
        switch (y) {
            // display the last move made if available
            case offset + 0:
                if (game.last_move.from != -1 && game.last_move.to != -1) {
                    printf(Debug1, "    Last Move: %c%c to %c%c", 
                        (game.last_move.from % 8) + 'A', 
                        '8' - (game.last_move.from / 8), 
                        (game.last_move.to   % 8) + 'A', 
                        '8' - (game.last_move.to   / 8) );
                }
                break;

            // display the time spent on the last move
            case offset + 1:
                if (0 == game.last_move_time) break;
                if (0 != game.last_moves_evaluated) {
                    // subtract 1 from the number of moves to not include the actual
                    // final move chosen in the count (it was already counted during consideration)
                    uint32_t num_moves = game.last_moves_evaluated;
                    double const moves_per_sec = num_moves / (game.last_move_time / 1000.0);

                    char str_moves[16] = "";
                    strcpy(str_moves, addCommas(num_moves));

                    char str_moves_per_sec[16] = "";
                    strcpy(str_moves_per_sec, addCommas(moves_per_sec));

                    char str_time[16] = "";
                    strcpy(str_time, addCommas(game.last_move_time));

                    printf(Debug1, "    %s moves in %s ms (%s moves/sec)", 
                        str_moves, str_time, str_moves_per_sec);
                }
                break;

            // display the number of moves evaluated on the last move
            // case offset + 2:
            //     if (0 == game.last_moves_evaluated) break;
            //     printf(Debug1, "    Moves evaluated: %s", addCommas(game.last_moves_evaluated));
            //     break;

            // display the pieces taken by White
            case offset + 4:
                printf(Debug1, "    Taken %d: ", 1);
                for (int i = 0; i < game.taken_count1; i++) {
                    char c = icons[(getSide(game.taken1[i]) * 6) + getType(game.taken1[i]) - 1];
                    printf(Debug1, "%c ", c);
                }
                break;

            // display the pieces taken by Black
            case offset + 5:
                printf(Debug1, "    Taken %d: ", 2);
                for (int i = 0; i < game.taken_count2; i++) {
                    char c = icons[(getSide(game.taken2[i]) * 6) + getType(game.taken2[i]) - 1];
                    printf(Debug1, "%c ", c);
                }
                break;

            // display the current score
            case offset + 7:
            {
                value = evaluate();

                char str_moves[16] = "";
                strcpy(str_moves, addCommas(value));
                printf(Debug1, "    Board value: %8s %s", str_moves, (value == 0) ? "" : 
                    (value  < 0) ? "Black's favor" : "White's favor");
            }
                break;
        }
        printf(Debug1, "%c", '\n');
    }
    printf(Debug1, "%s", 
        dev ? "   0  1  2  3  4  5  6  7\n\n" : "   A  B  C  D  E  F  G  H\n");

    set_led_strip();

}   // show()
